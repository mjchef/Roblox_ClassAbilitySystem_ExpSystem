# Классовая Система, Система получения опыта, Система управления способностями.

Этот раздел описывает архитектуру и взаимодействие основных систем, отвечающих за классы игроков, управление способностями.

---

## 1. Обзор Системы

Классовая система построена на модульном подходе, где каждый аспект (выбор класса, способности, анимации, инструменты, система опыта) управляется отдельными, но взаимосвязанными компонентами. Это обеспечивает чистоту кода, лёгкость расширения и надёжность.

Основные компоненты:

- **`ClassSystem`**: Модуль, управляющий выбором и назначением классов игрокам.
- **`AnimationManager`**: Централизованный модуль для управления загрузкой, хранением и воспроизведением анимаций для каждого класса.
- **`Tools` (Меч/Посох)**: Игровые инструменты, используемые игроками для атаки, интегрированные с классовой системой и менеджером анимаций.
- **`PlayerStats`**: Объект внутри игрока (`Player`), хранящий информацию о его текущем классе, **уровне и опыте**.
- **`ExperienceSystem`**: Модуль, управляющий начислением опыта, повышением уровня и связанными с этим механиками.

---

## 2. Механика Классовой Системы (`ClassSystem`)

`ClassSystem` — это основной модуль, который определяет класс игрока и управляет его состоянием.

### Процесс Выбора Класса

- **Инициализация:** При первом входе в игру или выполнении определённых условий, игроку становится доступен интерфейс выбора класса.
- **`RemoteEvent` (`SelectClass`):** Клиент отправляет на сервер событие `SelectClass`, сообщая о своём выборе.
- **Серверная обработка:** Серверный скрипт **`SelectClass`** (`ServerScriptService/SelectClass`) обрабатывает это событие:
    - Он проверяет выбранный класс на валидность.
    - Через `ClassSystem.assignClassPlayer()` **класс назначается игроку** (его название сохраняется в `Player.PlayerStats.Class.Value`).
    - `ClassSystem.applyClassParameters()` применяет специфические для класса параметры (например, к `Humanoid`).
- **Единоразовая инициализация `AnimationManager`:** При **первом** выборе класса игроком (поскольку выбор класса происходит только один раз за игровую сессию), скрипт `SelectClass` вызывает **`AnimationManager:Init()`**. Это гарантирует, что `AnimationManager` подпишется на необходимые глобальные события (например, появление/уход игрока/персонажа) **только один раз** за всю игровую сессию.

### Управление Классами

- `ClassSystem` содержит определения каждого класса (например, "Swordsman", "Wizard"), включая их начальные параметры и доступные способности.
- Класс игрока сохраняется в `Player.PlayerStats.Class.Value`, что делает его легко доступным для всех серверных скриптов, зависящих от класса.

---

## 3. Менеджер Анимаций (`AnimationManager`)

`AnimationManager` — это централизованный сервис, ответственный за управление `AnimationTrack`'ами в игре. Он предотвращает дублирование загрузок, эффективно управляет памятью и предоставляет доступ к анимациям другим системам.
Для тестирования необходимо добавить анимации по по пути  (`ServerStorage/Animations`)
### Принцип Работы

1. **Загрузка анимаций:**
    - Когда игрок выбирает класс (`SelectClass.OnServerEvent`), функция **`AnimationManager:LoadClassAnimations(player)`** вызывается. Она загружает все анимации для этого класса из `ServerStorage/Animations/[ClassName]` и кэширует их.
    - При **каждом респавне** персонажа игрока, `AnimationManager` (через подписку на `CharacterAdded`, установленную в `Init()`) автоматически вызывает `LoadClassAnimations()`. Это необходимо для перепривязки анимаций к новому `Animator` персонажа.
2. **Доступ к анимациям:**
    - Функция **`AnimationManager:GetAnimationsTrack()`** возвращает таблицу всех загруженных `AnimationTrack`'ов для текущего класса. Это позволяет другим скриптам (например, скрипту меча) легко получить нужную анимацию по её имени.
3. **Управление памятью:**
    - Перед загрузкой новых анимаций (`LoadClassAnimations`), менеджер **останавливает** (`:Stop()`) и **уничтожает** (`:Destroy()`) все ранее загруженные `AnimationTrack`'и, а затем очищает свою внутреннюю таблицу (`table.clear()`). Это предотвращает утечки памяти и обеспечивает актуальность анимаций.
    - При выходе игрока (`Players.PlayerRemoving`), `AnimationManager` выполняет полную очистку всех анимаций, освобождая ресурсы.

---

## 4. Использование `Tool` (Меч, Посох)

Игровые инструменты взаимодействуют с классовой системой и менеджером анимаций для выполнения атак и способностей. Данный компоненты были добавлены и собраны для демонстрации основных систем.

### Клиентский Скрипт Инструмента

- **`ContextActionService`:** При экипировке инструмента (`Tool.Equipped`), клиентский скрипт привязывает действия (например, "Swing" для атаки) к пользовательскому вводу.
- **Клиентская проверка класса:** Перед отправкой запроса на сервер, клиентский скрипт проверяет, соответствует ли класс игрока требуемому классу инструмента (`player.PlayerStats.Class.Value == CLASS_NEEDED`). Если нет, отображается UI-сообщение, предоставляя мгновенную обратную связь.
- **Отправка запроса на сервер:** При активации инструмента (`Tool.Activated`), клиент отправляет `RemoteEvent` (`Attack`) на сервер, передавая, например, индекс комбо-атаки.
- **Управление комбо-логикой:** Клиентский скрипт отслеживает `attackIndex` и `lastTime` для реализации комбо-последовательностей, а также использует флаг `isAttack` для предотвращения спама кликов на своей стороне.
- **Обратная связь от сервера:** Клиент слушает `RemoteEvent` от сервера (`Attack.OnClientEvent`), чтобы знать, когда сервер завершил обработку атаки, и может обновить `attackIndex` для следующего шага комбо.

### Серверный Скрипт Инструмента

- **Приём запроса:** Серверный скрипт инструмента (находящийся внутри `Tool` или управляемый из `ServerScriptService`) слушает `RemoteEvent` (`Attack.OnServerEvent`) от клиента.
- **Проверка и кулдаун:**
    - Сервер получает `player` и `index` атаки.
    - Он выполняет проверки на наличие персонажа (`player.Character`), `Humanoid` и `Animator`.
    - **Кулдаун:** Реализован динамический кулдаун, равный **длине воспроизводимой анимации** (`animationTrack.Length`). Это предотвращает спам и синхронизирует возможность атаки с визуальным завершением предыдущей.
- **Получение и воспроизведение анимации:**
    - Скрипт получает нужный `AnimationTrack` из **`AnimationManager:GetAnimationsTrack()`**. Поскольку `AnimationManager` уже был инициализирован и загрузил анимации к моменту, когда игрок использует инструмент, анимации **гарантированно доступны**.
    - Анимация воспроизводится **на сервере** (`animationTrack:Play()`), что обеспечивает её репликацию на клиент игрока и синхронизацию с серверной логикой урона.
- **Звуковые эффекты:** Воспроизводятся серверные звуки атаки.

---

## 5. Система Опыта (`ExperienceSystem`)

Система опыта отвечает за прогрессию игрока, позволяя ему повышать уровень и становиться сильнее.

### Принцип Работы

- **Хранение данных:** Уровень (`Level`) и текущий опыт (`Experience`) игрока хранятся в `Player.PlayerStats` (например, в `IntValue` или `NumberValue` объектах).
- **Начисление опыта:**
    - **Серверный контроль:** Опыт начисляется **только на сервере** (`ExperienceSystem` или в логике, управляющей убитыми противниками/выполненными квестами). Это предотвращает читерство.
    - Пример: Когда зомби убит, сервер вызывает `ExperienceSystem.AddExperience(player, amount)`.
- **Повышение уровня:**
    - `ExperienceSystem` содержит логику для определения, сколько опыта нужно для следующего уровня (например, через таблицы или формулы).
    - Когда опыт игрока достигает или превышает необходимое значение для текущего уровня, `ExperienceSystem`:
        - Увеличивает `Level` игрока.
        - Сбрасывает `Experience`, вычитая опыт, необходимый для предыдущего уровня (если это система "остаточного опыта").
        - Может активировать **события повышения уровня** (`LevelUpEvent`), которые другие скрипты могут слушать.
- **Эффекты повышения уровня:**
    - При повышении уровня могут быть применены различные эффекты:
        - Увеличение максимального здоровья, урона или других характеристик игрока.
        - Разблокировка новых способностей или улучшение существующих.
        - Воспроизведение визуальных эффектов (VFX) или звуков (SFX) для игрока.
        - Обновление UI, чтобы показать новый уровень и полосу опыта.

### Взаимодействие с другими системами

- **`PlayerStats`:** Система опыта напрямую манипулирует значениями `Level` и `Experience` в `Player.PlayerStats`.
- **Логика боя/квестов:** Модули, отвечающие за убийство противников или выполнение заданий, вызывают `ExperienceSystem.AddExperience()`.
- **UI:** Клиентский UI подписан на изменения `Player.PlayerStats.Level` и `Player.PlayerStats.Experience` для динамического отображения прогресса игрока.
